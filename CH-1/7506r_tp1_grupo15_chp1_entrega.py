# -*- coding: utf-8 -*-
"""7506R_TP1_GRUPO15_CHP1_ENTREGA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rvshgmJhXVLvYmGm3ZlNVbnJND5SP9tr

# Imports y Preparacion del dataset
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import sklearn.preprocessing as skp
import scipy.stats as stats
import scipy as sc
from sklearn.feature_extraction import FeatureHasher
from sklearn.feature_selection import VarianceThreshold
from sklearn.impute import KNNImputer, SimpleImputer
from sklearn.linear_model import LinearRegression
# multivariado   
from sklearn.ensemble import IsolationForest
from sklearn.neighbors import LocalOutlierFactor
from sklearn.neighbors import DistanceMetric

from sklearn import metrics

from google.colab import drive
drive.mount('/content/drive')

df = pd.read_csv('/content/drive/MyDrive/Datasets/hotels_train.csv') 
#f = pd.read_csv("/content/hotels_train.csv")
df_original = df.copy()

"""# a) Exploracion Inicial

Realizamos un analisis del dataset
"""

df.head()

print("La cant de filas del dataset es: ", df.shape[0])
print("La cant de columnas del dataset es: ", df.shape[1])

list(df.columns)

"""Vemos poco descriptiva la variable adr, por lo que le cambiamos el nombre"""

columnas = {"adr": "average_daily_rate", "arrival_date_year":"year", "arrival_date_month":"month", "arrival_date_day_of_month":"day"} #cambiar nombres a las categorias
df.rename(columns = columnas, inplace = True)
df.head(3)

"""## ● Tipo de variable"""

df.dtypes

"""## ●  Variables Cuantitativas

Las variables **cuantitativas** observadas del  dataset son: 
- lead time  (soporte continuo)
- stays_in_weekend_nights (rango discreto)
- stays_in_week_nights (rango discreto)
- adults (rango discreto)
- children  (rango discreto)
- babies (rango discreto)
- previous_cancellations 
- previous_bookings_not_canceled
- booking_changes 
- days_in_waiting_list 
- average daily rate
- required_car_parking_spaces
- total_of_special_requests
"""

variables_cuantitativas = ['lead_time', 'stays_in_weekend_nights','stays_in_week_nights', 'adults', 'children', 'babies', 'previous_cancellations', 'previous_bookings_not_canceled','booking_changes', 'days_in_waiting_list','average_daily_rate','required_car_parking_spaces','total_of_special_requests']
df[variables_cuantitativas].describe()

"""## ●  Variables Cualitativas

Las variables **cualitativas** observadas del dataset son:
-  hotel
- meal 
- country
- market_segment 
- distribution_channel 
- reserved_room_type
- assigned_room_type
- deposit_type
- customer_type
- reservation_status_date 
- is_canceled
- agent

.Reportar los posibles valores que toman y cuán frecuentemente lo hacen.
"""

print('Tipos de hotel')
print(df['hotel'].value_counts())

print('Meses de llegada')
print(df['month'].value_counts())

print(df['country'].unique()) #Vemos los paises de llegada registrados

print('Paises de origen')  
print(df['country'].value_counts().head(30)) #Veo los 30 paises de origen mas frecuentes
#print(df['country'].value_counts())

print('Tipos de comida reservada') #CAMBIAR en el paper dice: Undefined/SC – no meal package, tendriamos que corregir y ponerle al undefined SC
print(df['meal'].value_counts())

#CAMBIO EL UNDEFINED A SC :)
df.loc[df.loc[:,"meal"]=='Undefined',"meal"]="SC"
print(df['meal'].value_counts())

print('Segmento de mercado que pertenece el cliente')
print(df['market_segment'].value_counts())  #Aca podemos ver que hay 2 undefined a tratar mas adelante

print('Canal de distribucion en el que realiza la reserva')
print(df['distribution_channel'].value_counts()) #ANALISIS DE LOS 4 UNDEFINED

print('Tipo de habitacion reservada')
print(df['reserved_room_type'].value_counts())

print('Tipo de habitacion asignada')  #OJO PODEMOS HACER UNA EVALUACION ENTRE reserved_room_type y assigned_room_type
print(df['assigned_room_type'].value_counts())

print('Tipo de deposito')  
print(df['deposit_type'].value_counts())

print('Tipo de cliente')  
print(df['customer_type'].value_counts())

print(df['agent'].unique()) #Mosotramos todos los ID de los agentes en que se realizo la reserva

print('ID ddel agente en que se hizo la reserva')  
print(df['agent'].value_counts().head(20)) #Vemos los 20 ID de agentes mas frecuentes

"""## ● Determinar si existen variables irrelevantes para el análisis """

#filas_totales=df.shape[0]
#print(df.isna().sum()/filas_totales*100) #Esto va mas en datos faltantes
df.columns.values

"""Podemos obviar la columna
reservation_status_date no aporta info ya que se elimina reservation_status
arrival_date_week_number no es relevante para el analisis ya que no aporta mas informacion que la fecha de llegada
"""

df = df.drop(columns=['arrival_date_week_number'])

"""## ● Análisis gráfico de las distribuciones de las variables"""

colores=[(0,0,1),(0,1,0),(1,0,0),(1,0,1),(1,1,0),(0,1,1),(0,0,0)]

gr=df['hotel'].value_counts().plot.bar(alpha=0.5,color=colores ,title="Gráfico de tipos de Hotel ", xlabel="Meses de llegada",ylabel="Cantidad de reservaciones")

gr=df['month'].value_counts().plot.bar(alpha=0.5,color=colores ,title="Gráfico de meses de llegada al Hotel ", xlabel="Meses de llegada",ylabel="Cantidad de reservaciones")

gr=df['meal'].value_counts().plot.bar(alpha=0.5,color=colores ,title="Gráfico de meses de tipo de comida ", xlabel="Tipo de comida",ylabel="Cantidad de reservaciones")

#Parece que se necesita otro grafico!! PARECE QUE UN TREEMAP 

"""
#eje_y = ds_agrupado_Pclass['Survived'].tolist() 
sizes= (df["country"]).value_counts() # proportions of the categories

label=df["country"].unique()

squarify.plot(sizes=sizes, label=label, alpha=0.6).set(title='Treemap with Squarify')
plt.axis('off')
plt.show()  #TREE MAP TIRA ERROR PORQUE labels=150 y bars=149, dado que tengo datos faltantes 
"""
#gr=df['country'].value_counts().sort_values(ascending=False).plot.bar(figsize=(25,10), xlabel="Pais",ylabel="Frecuencia")
plt.figure(figsize=(25, 10))
gr=df['country'].value_counts().plot.bar(alpha=0.5,color=colores ,title="Gráfico de paises ", xlabel="Paises",ylabel="Cantidad de reservaciones")

#TENEMOS QUE VER LOS 2 UNDEFINED 
gr=df['market_segment'].value_counts().plot.bar(alpha=0.5,color=colores ,title="Gráfico de Segmento de mercado", xlabel="Segmento de Mercado",ylabel="Cantidad de reservaciones")

gr=df['distribution_channel'].value_counts().plot.bar(alpha=0.5,color=colores ,title="Gráfico de Canal de distribucion ", xlabel="Canal de distribucion",ylabel="Cantidad de reservaciones")

fig, ax = plt.subplots(1,2) #1 fila 2 col

colores=[(0,0,1),(0,1,0),(1,0,0),(1,0,1),(1,1,0),(0,1,1),(0,0,0)]

gr=df['reserved_room_type'].value_counts().plot.bar(alpha=0.5,color=colores ,title="Gráfico de tipo de habitacion reservada ", xlabel="Tipos de habitacion reservada",ylabel="Frecuencia")
plt.sca(ax[0])
plt.xticks(fontsize=10, rotation=90)

plt.tight_layout() #espacio entre subplots

gr=df['assigned_room_type'].value_counts().plot.bar(alpha=0.5,color=colores ,title="Gráfico de tipo de habitacion asignada ", xlabel="Tipo de habitacion asignada",ylabel="Frecuencia")
plt.sca(ax[1])
plt.xticks(fontsize=10, rotation=90)
plt.show()

gr=df['deposit_type'].value_counts().plot.bar(alpha=0.5,color=colores ,title="Gráfico de tipo de depositos", xlabel="Tipo de deposito",ylabel="Frecuencia")

gr=df['customer_type'].value_counts().plot.bar(alpha=0.5,color=colores ,title="Gráfico de tipo de cliente", xlabel="Tipo de cliente",ylabel="Frecuencia")

#Graficamos las variables cuantitativas
#Vemos graficos de histogramas y densidad(histograma suavizado)
sns_hist=sns.histplot(data=df['lead_time'], kde=True, alpha = 0.5).set(title="Tiempo de espera",xlabel="Tiempo de espera en dias",ylabel="Cantidad de personas que reservaron")

#gr=df['stays_in_weekend_nights'].value_counts().plot.bar(alpha=0.5,title="Gráfico de tipo de depositos", xlabel="Tipo de deposito",ylabel="Frecuencia")
#Es de soprte discreto pero no llego a ver la distribucion en los ultimos por lo que decido
fig, ax = plt.subplots(1,2) #1 fila 2 col


grf=df['stays_in_weekend_nights'].plot.box(title="Boxplot estadia noches fin de semana",xlabel=" ",ylabel="Cant de noches de sabado/domingo")

plt.sca(ax[0])
plt.xticks(fontsize=10, rotation=90)

plt.tight_layout() #espacio entre subplots
grf=df['stays_in_week_nights'].plot.box(title="Boxplot estadia noches lunes-viernes",xlabel=" ",ylabel="Cant de noches de lunes-viernes")
plt.sca(ax[1])
plt.xticks(fontsize=10, rotation=90)

fig, ax = plt.subplots(1,3) #1 fila 3 col


grf=df['adults'].plot.box(title="Boxplot cant de adultos",xlabel=" ",ylabel="Cant de adultos") 

plt.sca(ax[0])
plt.xticks(fontsize=10, rotation=90)
plt.tight_layout()

grf=df['children'].plot.box(title="Boxplot cant de niños",xlabel=" ",ylabel="Cant de niños") 
plt.sca(ax[1])
plt.xticks(fontsize=10, rotation=90)
plt.tight_layout()

grf=df['babies'].plot.box(title="Boxplot cant de bebes",xlabel=" ",ylabel="Cant de bebes") 
plt.sca(ax[2])
plt.xticks(fontsize=10, rotation=90)
plt.show()
#Vemos que la mayoria de reservaciones a grandes rasgos son de 0 a 10 adultos

fig, ax = plt.subplots(1,2) #1 fila 3 col


grf=df['previous_cancellations'].plot.box(title="Boxplot cant cancelaciones anteriores",xlabel=" ",ylabel="Cant de cancelaciones anteriores")
plt.sca(ax[0])
plt.xticks(fontsize=10, rotation=90)

plt.tight_layout()

grf=df['previous_bookings_not_canceled'].plot.box(title="Boxplot cant confirmaciones anteriores",xlabel=" ",ylabel="Cant de confirmaciones anteriores") 
plt.sca(ax[1])
plt.xticks(fontsize=10, rotation=90)
plt.show()

grf=df['booking_changes'].plot.box(title="Boxplot cant de cambios",xlabel=" ",ylabel="Cant de cambios")

grf=df['average_daily_rate'].plot.box(title="Boxplot precio promedio diario",xlabel=" ",ylabel="Precio")

"""## ● Analisis de las correlaciones existentes entre las variables

Correlacion de variables cuantitativas
"""

#df_booking_changes = df[variables_cuantitativas] #d'f filtrado
matriz_correlacion =(df[variables_cuantitativas]).corr()
plt.figure(figsize=(12, 12))
sns.heatmap(matriz_correlacion, annot = True) 
#plt.figure(figsize=(4, 2))
#df.plot(figsize=(12,18))
#sns.set(rc = {'figure.figsize':(16,9)})
plt.show()

"""Analisis de correlaciones:
- stays_in_week_nights and stays_in_weekend_nights: correlacion positiva
- lead_time and average_daily_rate: correlacion negativa 
- average_daily_rate and children : correlacion positiva
- average_daily_rate and adults : correlacion positiva
- average_daily_rate and total_of_special_request : correlacion positiva

OJO: es un analisis previo(con outliers) todavia no podemos asegurar que correlacion indica dependencia.
"""

#variables cualitativas VDeCramer

"""## ● Analizar la relación de las variables con el target (is_canceled)


"""

df.corr().loc[:, 'is_canceled'] #Muestra la correlacion de mi variable is_canceled con cada una de las categorias.

"""Vemos que la variable que mayor relacion tiene con el target(is_canceled) es lead_time. Esto tiene sentido dado que si hay mucho tiempo de espera es mas propenso a cancelar la reserva.

Mostramos un heatmap de la correlacion que existe con todas las variables
"""

matriz_correlacion =df.corr()
plt.figure(figsize=(15, 12))
sns.heatmap(matriz_correlacion, annot = True) 
#sns.set(rc = {'figure.figsize':(20,12)})
#df.plot(figsize=(30,18))

plt.show()

"""# b) Visualización de los datos"""

#Scatter plot 
#Decidimos ver la relacion de las cancelaciones previas y los dias en lista de espera relacionandolo con el target.
col = df.is_canceled.map({0:'g', 1:'r'})
grf=df.plot.scatter(x="previous_cancellations", y="days_in_waiting_list", c=col, s=10).set(title="Dispersograma",xlabel='Previous Cancellations',ylabel='Days in waiting list')

""" Vemos que si hizo mas de 8 cancelaciones previas, es muy probable que cancele la reserva.
 
Tambien vemos que si estuvo mas de 280 dias en la lista de espera y a pesar que no tuvo ninguna cancelacion previa, es probable que cancele la reserva.
"""

#Consideramos que puede haber una relacion entre el target y que le asignen la misma habitacion que reservaron o el caso contrario.
room_assigned_equal_reserved = df[((df['reserved_room_type'] == df['assigned_room_type']) ) ]
room_assigned_different_reserved = df[((df['reserved_room_type'] != df['assigned_room_type']) )]
#plt.figure(figsize=(4, 2))
gr= room_assigned_equal_reserved['is_canceled'].value_counts().plot.bar(alpha=0.5,color=colores ,title="Gráfico de cancelacion con la misma habitacion", xlabel="Cancelo",ylabel="Cantidad de cancelaciones")

"""En este grafico, vemos que a los que le asignaron el mismo tipo de habitacion que reservaron, tienden a cancelar mas. Esto tendria logica si lo pensamos de la manera en que al realizado la reserva, a los clientes les hubiera gustado que se le asigne una de mejor categoria."""

gr= room_assigned_different_reserved['is_canceled'].value_counts().plot.bar(alpha=0.5,color=colores ,title="Gráfico de cancelacion con una diferente habitacion", xlabel="Cancelo",ylabel="Cantidad de cancelaciones")

"""Por otro lado, vemos que a los que le asignaron distinto tipo de habitacion que reservaron, tienden a no cancelar . Asi mismo, aca consideramos que los que eservaron se les termino asignando una habitacion de mejor categoria.

Ahora, decidimos agrupar 3 columnas del dataset a una sola que indique el dia de llegada y castearlo a tipo datetime
"""

months = {'January':1, 'February':2, 'March':3, 'April':4, 'May':5, 'June':6, 'July':7, 'August':8,'September':9, 'October':10,'November':11, 'December': 12 }
df.month = df.month.map(months)

arrivaldates = df.copy() 
import datetime

date=arrivaldates.apply(lambda x: datetime.date(int(x['year']), x['month'], x['day']),axis=1)

date = pd.to_datetime(date)

df = df.drop(columns=['year', 'month', 'day'])

df.insert(0, 'arrival_date', date)

df.head() #Imprimimos para asegurarnos que se hizo el cambio correctamente

"""# c) Datos Faltantes

## ● Analisis de datos faltantes por columna
"""

#Vemos el porcentaje de datos faltantes en porcentaje
filas_totales=df.shape[0]
print(df.isna().sum()/filas_totales*100)

"""## ● Graficar para cada variable el porcentaje de datos faltantes con respecto al total del dataset"""

porcentaje_datos_faltantes = (df.isna().sum()/filas_totales*100)
graph = sns.barplot(x=porcentaje_datos_faltantes.index, y=porcentaje_datos_faltantes.values)
graph.axhline(100)
plt.ylabel("Datos faltantes %")
plt.xlabel("Categorias")
plt.xticks(rotation=90)
plt.tight_layout()

#Decidimos eliminar la columna de company dado que el porcentaje de datos nulos es bastante alto, y seria casi imposible poder modificarlo.
#Tambien decidimos eliminar la columna 'reservation_status_date' dado que en la catedra se decidio eliminar la categoria 'reservation_status', y ya no tendria que afectar en nada a nuestro analisis.
df= df.drop(columns=['company', 'reservation_status_date'])
print(df.columns.to_list()) #para asegurarnos que fueron eliminados

"""## ● Comparar las distribuciones de los atributos modificados"""

#Sabemos que hay datos nulos en children, por lo que queremos ver cuantos son.
df['children'].isna().sum()

df[np.isnan(df['children']) == True]

"""Vemos que los 4 casos viajan a un city_hotel en agosto del 2015 con 2 adultos, 0 bebes y desde Portugal."""

predicted_children = df[(df['hotel'] == 'City Hotel') & (df['adults']== 2) & (df['babies'] == 0) & (df['country'] == 'PRT') & df['arrival_date'].between('2015-08-01', '2015-08-31')]
predicted_children['children'].mode() #vemos que con esas caracteristicas, la moda me da 0, decido modificarlo por 0s

df['children'] = df['children'].fillna(0.0)
df['children'].astype(int)

fig, ax = plt.subplots(1,2) #1 fila 2 col

colores=[(0,0,1),(0,1,0),(1,0,0),(1,0,1),(1,1,0),(0,1,1),(0,0,0)]

gr=df_original['children'].value_counts().plot.bar(alpha=0.5,color=colores ,title="Gráfico de cant niños antes ", xlabel="Cant de niños",ylabel="Frecuencia")
plt.sca(ax[0])
plt.xticks(fontsize=10, rotation=90)

plt.tight_layout() #espacio entre subplots

gr=df['children'].value_counts().plot.bar(alpha=0.5,color=colores ,title="Gráfico de cant de niños despues ", xlabel="Cant de niños",ylabel="Frecuencia")
plt.sca(ax[1])
plt.xticks(fontsize=10, rotation=90)
plt.show()

"""Vemos que la distribucion no fue afectada, esto tambien se ebe dado que la cantidad de nulos era muy baja con respecto al total de datos."""

#Sabemos que hay datos nulos en children, por lo que queremos ver cuantos son.
df['agent'].isna().sum()

df['agent'].mode() #decidimos calcular la moda (el valor con mayor freuencia)

df['agent'] = df['agent'].fillna(9.0) #Cambiamos los datos faltantes por la moda, dado que es el que mas se repite y poder afectar menos nuestra distribucion

df['agent'].isna().sum() #Verificamos que el cambio se hizo correctamente

sns_hist=sns.histplot(data=df['agent'], kde=True, alpha = 0.5).set(title="Agente",xlabel="Agente",ylabel="Cantidad de personas que reservaron con este agente")

sns_hist=sns.histplot(data=df_original['agent'], kde=True, alpha = 0.5).set(title="Agente",xlabel="Agente",ylabel="Cantidad de personas que reservaron con este agente")

df_original['country'].mode() #Tiene sentido porque son hoteles de portugal

df['country'] = df['country'].fillna('PRT')

fig, ax = plt.subplots(1,2) #1 fila 2 col

colores=[(0,0,1),(0,1,0),(1,0,0),(1,0,1),(1,1,0),(0,1,1),(0,0,0)]

gr=df['country'].head(300).value_counts().plot.bar(alpha=0.5,color=colores ,title="Paises distrbucion despues ", xlabel="Pais",ylabel="Cantidad de reservaciones")
plt.sca(ax[0])
plt.xticks(fontsize=10, rotation=90)

plt.tight_layout() #espacio entre subplots


gr=df_original['country'].head(300).value_counts().plot.bar(alpha=0.5,color=colores ,title="Paises distrbucion antes", xlabel="Pais",ylabel="Cantidad de reservaciones")
plt.sca(ax[1])
plt.xticks(fontsize=10, rotation=90)
plt.show()

"""Vemos que la distribucion se conserva

# d)  Valores atípicos

## ● Detectar valores atipicos de forma univariada y multivariada con graficos
"""

sns.boxplot(y=df.adults)
plt.show()

#z-score Peso con librería stats
zadultos = df.loc[:,['adults', 'is_canceled']]
zadultos['z_adults']=stats.zscore(df.adults)
zadultos[(zadultos['z_adults']>=3) | (zadultos['z_adults']<=-3)]

"""Segun z-score 4 es outlier pero es un valor normal de una reserva, tomamos outliers reservas de mas de 40 personas"""

sns.boxplot(y=df.children)
plt.show()

df[df['children'] > 8]

"""Tomamos como outliers las reservas con mas de 8 niños """

sns.boxplot(y=df.days_in_waiting_list)
plt.show()

#z-score days in waiting list
zdiwl = df.loc[:,['days_in_waiting_list', 'is_canceled']]
zdiwl['z_diwl']=stats.zscore(df.days_in_waiting_list)
zdiwl_outliers = zdiwl[(zdiwl['z_diwl']>=3) | (zdiwl['z_diwl']<=-3)]
zdiwl_outliers

zprevious_cancellations = df.loc[:,['previous_cancellations', 'is_canceled']]
zprevious_cancellations['z_previous_cancellations']=stats.zscore(df.previous_cancellations)
zprevious_cancellations_outlier = zprevious_cancellations[(zprevious_cancellations['z_previous_cancellations']>=3) | (zprevious_cancellations['z_previous_cancellations']<=-3)]
zprevious_cancellations_outlier.sort_values('previous_cancellations')

adults_atipico = df[df['adults']==0];
adults_atipico

children_with_babies_atipico = adults_atipico[adults_atipico['babies']!=0]
children_with_babies_atipico

"""Tomamos como outlier a la reserva de niño con bebe sin adulto"""

children_atipico = adults_atipico[adults_atipico['babies']==0]
children_atipico

children_babies_adults_on_zero = adults_atipico[(adults_atipico['children']==0) & (adults_atipico['babies']==0)] 
children_babies_adults_on_zero

sin_dias = df[(df['stays_in_weekend_nights']==0) &(df['stays_in_week_nights'] ==0)]
sin_dias

df[df['average_daily_rate']==0]

"""Lo interpretamos como valor atipico ya que en caso de que haya sido un regalo el hotel registraria el valor de la estadia."""

def mahal_dists(X):
    sample_X = X.sample(frac=0.1)
    mu = sample_X.mean()
    X_diff = X - mu
    X_diff = X_diff.values.T
    cov = np.cov(sample_X.values.T)
    inv_cov = np.linalg.inv(cov)
    W = sc.linalg.sqrtm(inv_cov)
    Wx = np.matmul(W, X_diff)
    return np.array([np.dot(Wx[:, i], Wx[:, i]) for i in range(Wx.shape[1])])

df_corr = df[['previous_cancellations','days_in_waiting_list']].copy()
mahal = mahal_dists(df_corr)
df_corr['mahalanobis'] = mahal
df_corr.head()

sns.boxplot(y=df_corr.mahalanobis)

"""## ● Explicar caracteristicas de los datos atipicos detectados

Datos que datos claramente atipicos son reservas:


*   Solo niños con bebes
*   Solo bebes
*   Sin ningun participante
*   Sin dias tanto en fines de semana como dias de semana
*   De grupos grandes
*   De grupos con mas de 8 niños
*   Average daily rate en cero
*   Average daily rate es negativo
*   Days in waiting list de mas de un año
"""



"""## ● Decision del tratamiento a aplicar

Podemos eliminar las filas que no tengan adultos ninios o bebes tanto como las filas que solo tengan bebes en las reservas ya que son un porcentaje inferior a x del dataset

# Conclusion

Si una persona es un outlier en previous_cancellations y en days_in_waiting_list probablemente cancele
"""

df.agg(['min','max']) #vemos que adr da negativo no se quedo en fin de semana ni en dia de semana pero NO se cancelo

#encontramos una fila con dato outlier, adr = -6.38
df_adr_menor_a_cero = df.loc[df['average_daily_rate'] < 0]
df_adr_menor_a_cero

#eliminamos el outlier porque una fila respecto a la gran cantidad de datos que tenemos no es relevante
df.drop(df[df['average_daily_rate']<0].index, axis='index',inplace=True)

#pd.crosstab(df['is_canceled'],df['distribution_channel'])
#pd.crosstab(df['is_canceled'],df['meal'])
pd.crosstab(df['is_canceled'],df['deposit_type'])

pd.crosstab(df['is_canceled'],df['deposit_type'])

pd.crosstab(df_original['is_canceled'],df_original['arrival_date_month'])

df_booking_changes = df[['is_canceled', 'total_of_special_requests','average_daily_rate','babies', 'days_in_waiting_list','lead_time', 'previous_cancellations', 'previous_bookings_not_canceled']] #d'f filtrado

matriz_correlacion = df_booking_changes.corr()
sns.heatmap(matriz_correlacion, annot = True) 
plt.show()  #vemos que lead_time tiene mayor relacion con la cancelacion

df_booking_changes

plt.scatter(df['average_daily_rate'],df['is_canceled'],color='blue',alpha=0.5)
#posibles 4 puntos outliers

plt.scatter(df['previous_cancellations'],df['is_canceled'],color='blue',alpha=0.5)
#superando las 10 cancelaciones previas es MUY probable que cancelen
plt.ylabel('Cancelled') 
plt.xlabel('Previous Cancellations') 
plt.show()

ds_agrupado_Month=df_original.groupby(['arrival_date_month']).count()
eje_x = ds_agrupado_Month.index.tolist()
eje_y = ds_agrupado_Month['is_canceled'].tolist()
sns_bar_plot=sns.barplot(x=eje_x, y=eje_y, data=ds_agrupado_Month ,alpha=0.5).set(title="Frecuencia",ylabel='Cancelled',xlabel='Month')
plt.xticks(rotation=90)

"""*Sacar* porcentaje de cuantas reservas fueron canceladas en cada mes

```
# Esto tiene formato de código
```

Mahalanobis para outliers
"""



"""Analizar la media de las variables
Veamos que % representa lo que se puede sacar
"""